


Rcpp::List cpp_NGLearn_onlineADAM(const arma::mat& X, arma::mat W, 
                                  double alpha, double beta1, double beta2, 
                                  double lambda, double lambda_decay, 
                                  double tol_delBMU = 1.0, double tol_delQE = 1.0, 
                                  int max_epochs = -1, 
                                  Rcpp::Nullable<Rcpp::IntegerVector> XLabel = R_NilValue) {
  
  // Inputs: 
  // X = data matrix, in external network range
  // minX,maxX = limits of external network range; now compute this internally  
  // W = prototype matrix, in internal network range [0,1] 
  // lambda = starting lambda value for training 
  // decay = decay rate, annealing done at every epoch according to lambda = lambda * decay
  
  // Setup random generator for sampling indices
  std::default_random_engine generator;
  std::uniform_int_distribution<unsigned int> distribution(0,X.n_rows-1);
  
  // *** Initialize containers related to learning 
  double minX = X.min();        // external network range
  double maxX = X.max(); 
  double alpha0 = alpha;        // initial learning rate 
  double lambda0 = lambda;      // initial neighborhood  
  arma::rowvec x = X.row(0);    // the scaled sample @ each iter
  arma::uvec rank(W.n_rows);    // the prototype rank @ each iter 
  unsigned int iter = 0;        // num of learning iters performed so far 
  unsigned int age = 0;         // num of learning epochs performed so far (epoch = nX iters, nX = nrow(X))
  
  // *** Initialize containers related to monitoring & reporting 
  unsigned int npass_delBMU = 0;  // num of consecutive monitorings the delBMU tol has been met 
  unsigned int npass_delQE = 0;   // num of consecutive monitorings the delQE tol has been met 
  bool exit_flag = false;         // whether all conv criteria have been met 
  
  
  arma::uvec nXsampled(X.n_rows);  // num of times each data vector has been sampled 
  nXsampled.zeros();          
  arma::uvec BMU(X.n_rows);       // BMUs of all data @ current monitoring
  BMU.fill(W.n_rows);         
  arma::uvec prevBMU(X.n_rows);   // BMUs of all data @ previous monitoring 
  prevBMU.fill(W.n_rows); 
  arma::vec QE(X.n_rows);         // QE of all data @ current monitoring 
  QE.fill(std::sqrt(X.n_cols)); 
  arma::vec prevQE(X.n_rows);     // QE of all data @ previous monitoring 
  prevQE.fill(std::sqrt(X.n_cols)); 
  
  // Monitor Storage  
  std::vector<unsigned int> mtr_age; 
  std::vector<double> mtr_alpha; 
  std::vector<double> mtr_lambda; 
  std::vector<double> mtr_delBMU; 
  std::vector<double> mtr_MQE; 
  std::vector<double> mtr_delQE; 
  std::vector<double> mtr_RFEnt;
  std::vector<double> mtr_RFLPur;
  std::vector<double> mtr_RFLBatt; 
  std::vector<unsigned int> mtr_RFLUnq;
  
  
  
  
  // Initialize prototype distance & update workers 
  dist_prototypes_prlwkr DistWorker(W, x);
  update_prototypes_ADAM_prlwkr UpdateADAMWorker(W, lambda, x, rank, iter, alpha, beta1, beta2);
  
  
  // *** Initialize the monitoring worker
  // If labels were given, assign them to the worker as well 
  VQQuality_worker VQMwkr(BMU, W.n_rows);
  bool is_labeled = false;
  if(XLabel.isNotNull()) {
    arma::uvec XLabel_;
    XLabel_ = Rcpp::as<arma::uvec>(XLabel);
    VQMwkr.set_XLabel(XLabel_);
    is_labeled = true;
  }
  
  
  
  // *** Start learning 
  auto start_time = std::chrono::high_resolution_clock::now(); 
  while(!exit_flag) {
    
    iter++; 
    
    // Sample an x and scale it to [0,1]
    unsigned int Xidx = distribution(generator);
    nXsampled(Xidx)++; 
    x = (X.row(Xidx) - minX) / (maxX - minX); 
    
    // Compute distances to all prototypes, rank them
    DistWorker.calc_parallel(); 
    
    //unsigned int thisBMU; double thisQE; 
    rank_prototypes(rank, BMU(Xidx), QE(Xidx), DistWorker.dist); 
    
    // Update prototypes 
    UpdateADAMWorker.calc_parallel(); 
    
    
    if( iter % X.n_rows == 0) {
      // Increment age
      age++;
      
      // Print headers first, and after every 10 reports 
      if(age==1 || age % 11==0) {
        Rprintf("%5s%10s%10s%10s%10s%10s%10s%10s", "Epoch", "Samp%", "alpha", "lambda", "delBMU", "MQE", "delQE", "RFEnt");
        if(is_labeled) Rprintf("%10s%10s%10s", "RFLPur", "RFLBatt", "RFLUnq"); 
        Rprintf("\n");
      }
      
      //Rprintf("Epoch: %3u; ", age);
      Rprintf("%5u", age);
      mtr_age.push_back(age);
      
      //Rprintf("Samp%%: %0.3f; ", double(arma::sum(nXsampled > 0)) / double(X.n_rows)); 
      Rprintf("%10.1f", double(arma::sum(nXsampled > 0)) / double(X.n_rows) * 100.0); 
      
      //Rprintf("alpha: %0.3f; ", alpha);
      Rprintf("%10.3f", alpha);
      mtr_alpha.push_back(alpha);
      //Rprintf("lam: %0.3f; ", lambda);
      Rprintf("%10.3f", lambda);
      mtr_lambda.push_back(lambda);
      
      // *** Compute & Report Quantization Measures
      // Only want to report the BMU and QE change for data which has been presented to the network 
      arma::uvec report = arma::find(nXsampled > 1); 
      
      
      // Propotion of BMUs that are different from last epoch
      arma::uvec nBMUmismatch = arma::find(BMU.elem(report) != prevBMU.elem(report));
      double delBMU = double(nBMUmismatch.n_elem) / double(X.n_rows) * 100.0;
      if(age == 1) delBMU = std::numeric_limits<double>::quiet_NaN();
      //Rprintf("delBMU: %0.3f; ",  delBMU);
      Rprintf("%10.3f",  delBMU);
      mtr_delBMU.push_back(delBMU);
      prevBMU = BMU;
      
      // Mean Quantization Error of this epoch
      double MQE = arma::mean(QE.elem(report));
      //Rprintf("MQE: %0.5f; ", MQE );
      Rprintf("%10.5f", MQE );
      mtr_MQE.push_back(MQE);
      
      // Relative percent change of each x's QE, averaged over all X
      // Add a small # to the QE to avoid division by 0
      arma::vec vecdelQE = (prevQE.elem(report) - QE.elem(report)) / (prevQE.elem(report) + std::numeric_limits<double>::min());
      double delQE = arma::mean(arma::abs( vecdelQE )) * 100.0;
      //double delQE = std::abs(MQE - prevMQE) / (prevMQE + std::numeric_limits<double>::min()) * 100; 
      if(age == 1) delQE = std::numeric_limits<double>::quiet_NaN();
      //Rprintf("delQE: %0.3f; ", delQE );
      Rprintf("%10.3g", delQE );
      mtr_delQE.push_back(delQE);
      prevQE = QE;
      //prevMQE = MQE; 
      
      // Update monitor helper
      // Must call this after computation of delBMU & delQE, as it uses the current values of BMU & QE in its calculations
      VQMwkr.calc_parallel();
      
      // Normalized Entropy of RF sizes
      double RFEnt = VQMwkr.calc_RFEntropy();
      //Rprintf("RFEnt: %0.3f; ", RFEnt );
      Rprintf("%10.3f", RFEnt );
      mtr_RFEnt.push_back(RFEnt);
      
      if(is_labeled) {
        // Purity of labels in each RF = count(plurality label) / RFSize
        double RFLPur;
        RFLPur = VQMwkr.calc_WAvgPurity();
        //Rprintf("RFLPur: %0.3f; ", RFLPur );
        Rprintf("%10.3f", RFLPur );
        mtr_RFLPur.push_back(RFLPur);
        
        // Battacharyya Distance between discrete distribution of X labels vs RF labels
        double RFLBatt;
        RFLBatt = VQMwkr.calc_BhattacharyyaDist();
        //Rprintf("RFLBatt: %0.3f; ", RFLBatt );
        Rprintf("%10.3f", RFLBatt );
        mtr_RFLBatt.push_back(RFLBatt);
        
        unsigned int RFLUnq;
        RFLUnq = VQMwkr.calc_RFLabelCount();
        //Rprintf("RFLUnq: %d; ", RFLUnq );
        Rprintf("%10d", RFLUnq );
        mtr_RFLUnq.push_back(RFLUnq);
      }
      Rprintf("\n");
      
      
      // *** Check for convergence
      if(age>1 && delBMU < tol_delBMU) npass_delBMU++; else npass_delBMU = 0;
      if(age>1 && delQE < tol_delQE) npass_delQE++; else npass_delQE = 0;
      
      if(npass_delBMU >= 3 && npass_delQE >= 3) exit_flag = true;
      if(max_epochs > 0 && int(age) >= max_epochs) exit_flag = true;
      
      
      // *** Check for user interrupt 
      // Return partial results
      try {Rcpp::checkUserInterrupt();} catch(Rcpp::internal::InterruptedException e) {break;}
      
      
      // // *** Anneal neighborhood
      // // Do this last, so that lambda doesn't decay anymore if we have terminated in check above 
      // alpha *= alpha_decay; 
      // lambda *= lambda_decay;
      
    } // close epoch monitoring 
    
    // *** Anneal neighborhood
    // Do this last, so that lambda doesn't decay anymore if we have terminated in check above 
    //alpha *= alpha_decay; 
    lambda *= lambda_decay;
    
  } // close learning 
  
  // Stop the clock 
  auto stop_time = std::chrono::high_resolution_clock::now(); 
  //auto exec_time = std::chrono::duration_cast<std::chrono::minutes>(stop_time - start_time);
  //auto exec_time = std::chrono::duration<float, std::chrono::minutes>(stop_time - start_time); 
  std::chrono::duration<double, std::ratio<60,1>> exec_time = stop_time - start_time;
  
  // Scale W back to data range 
  W = W*(maxX - minX) + minX; 
  
  
  // Build learning history data frame 
  Rcpp::DataFrame LearnHist; 
  LearnHist.push_back(mtr_age, "Epoch"); 
  LearnHist.push_back(mtr_alpha, "alpha");
  LearnHist.push_back(mtr_lambda, "lambda");
  LearnHist.push_back(mtr_delBMU, "delBMU"); 
  LearnHist.push_back(mtr_MQE, "MQE");
  LearnHist.push_back(mtr_delQE, "delQE");
  LearnHist.push_back(mtr_RFEnt, "RFEnt");
  if(is_labeled) {
    LearnHist.push_back(mtr_RFLPur, "RFLPur");
    LearnHist.push_back(mtr_RFLBatt, "RFLBatt");
    LearnHist.push_back(mtr_RFLUnq, "RFLUnq");
  }
  LearnHist = Rcpp::as<Rcpp::DataFrame>(LearnHist);
  
  
  // Build output list 
  Rcpp::List out; 
  out["W"] = W; 
  out["age"] = age; 
  out["alpha_start"] = alpha0;
  out["alpha_end"] = alpha; 
  //out["alpha_decay"] = alpha_decay; 
  out["lambda_start"] = lambda0;
  out["lambda_end"] = lambda; 
  out["lambda_decay"] = lambda_decay; 
  out["tol_delBMU"] = tol_delBMU; 
  out["tol_delQE"] = tol_delQE; 
  out["max_epochs"] = max_epochs; 
  out["exec_time"] = exec_time.count(); 
  out["LearnHist"] = LearnHist;
  
  return out; 
  
}

